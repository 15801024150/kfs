//---------------------------------------------------------- -*- Mode: C++ -*-
// $Id: clientsm.cc 3365 2011-11-23 22:40:49Z sriramr $
//
// Created 2011/01/04
//
// Copyright 2011 Yahoo Corporation.  All rights reserved.
// This file is part of the Sailfish project.
//
// Licensed under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
//
//
//----------------------------------------------------------------------------

#include "clientsm.h"
#include "util.h"
#include "workbuilder.h"
#include "common/kfstypes.h"

#include "common/log.h"
#include "common/BufferedLogWriter.h"
#include <boost/algorithm/string.hpp>
using namespace KFS;
using namespace workbuilder;
using std::string;
using std::vector;

ClientSM::ClientSM(NetConnectionPtr &conn) : mNetConnection(conn)
{
    mClientIP = mNetConnection->GetPeerName();
    SET_HANDLER(this, &ClientSM::HandleRequest);
}

ClientSM::~ClientSM()
{
    // we could log info about how long it took to handle a request
}

///
/// Send out the response to the client request.  The response is
/// generated by MetaRequest as per the protocol.
/// @param[in] op The request for which we finished execution.
///
void
ClientSM::SendResponse(const WorkbuilderOp &op)
{
    IOBuffer::OStream os;

    op.show(os);

    mNetConnection->Write(&os);
}


///
/// Return true if there is a sequence of "\r\n\r\n".
/// @param[in] iobuf: Buffer with data
/// @param[out] msgLen: string length of the command in the buffer
/// @retval true if a command is present; false otherwise.
///
bool
IsMsgAvail(IOBuffer *iobuf,
           int *msgLen)
{
    const int idx = iobuf->IndexOf(0, "\r\n\r\n");
    if (idx < 0) {
        return false;
    }
    *msgLen = idx + 4; // including terminating seq. length.
    return true;
}

static void
loadParams(string &str, Properties &prop)
{
    vector<string> kv;

    // A request we get is of the form:
    //  x=y&a=b&c=d
    // So, first split using '&' to get a bunch of key/value pairs
    split(str, kv, '&');
    for (uint32_t i = 0; i < kv.size(); i++) {
        vector<string> parts;

        // each kv pair is delimited by a '='
        split(kv[i], parts, '=');
        if (parts.size() >= 2) {
            // fix up HTML escaping of ":" character %3A
            string::size_type escColon = parts[1].find("%3A");
            if (escColon == string::npos)
                escColon = parts[1].find("%3a");

            if (escColon != string::npos) {
                string p1, p2;

                p1.assign(parts[1], 0, escColon);
                p2.assign(parts[1], escColon+3, string::npos);
                parts[1] = p1 + ":" + p2;
            }
            prop.setValue(parts[0], parts[1]);
        }
    }
}

static string
removeLTSlashes(string &str)
{
    char const* delims = " /\t\r\n";

    // trim leading whitespace and /
    string::size_type  notwhite = str.find_first_not_of(delims);
    str.erase(0,notwhite);

   // trim trailing whitespace and /
   notwhite = str.find_last_not_of(delims);
   if (notwhite != string::npos)
       str.erase(notwhite+1);
   return(str);
}


///
/// Generic event handler.  Decode the event that occurred and
/// appropriately extract out the data and deal with the event.
/// @param[in] code: The type of event that occurred
/// @param[in] data: Data being passed in relative to the event that
/// occurred.
/// @retval 0 to indicate successful event handling; -1 otherwise.
///
int
ClientSM::HandleRequest(int code, void *data)
{
    IOBuffer *iobuf;
    int cmdLen;
    int hdrsz;

    switch (code) {
	case EVENT_NET_READ:
            // We read something from the network.  Run the RPC that
            // came in.
            iobuf = (IOBuffer *) data;
            while (IsMsgAvail(iobuf, &cmdLen)) {
                if (!HandleClientCmd(iobuf, cmdLen))
                    break;
            }
            // XXX: Do we care it is a big message?
            if ((hdrsz = iobuf->BytesConsumable()) > 5 * MAX_RPC_HEADER_LEN) {
                KFS_LOG_VA_ERROR("exceeded max request header size: %d > %d,"
                                 " closing connection\n", (int)hdrsz, (int)MAX_RPC_HEADER_LEN);
                iobuf->Clear();
                HandleRequest(EVENT_NET_ERROR, NULL);
            }
            break;

	case EVENT_NET_WROTE:
            // Something went out on the network.  If everything went
            // out, close the connection
            iobuf = (IOBuffer *) data;
            if (iobuf->IsEmpty()) {
                mNetConnection->Close();
                delete this;
            }
            break;

        case EVENT_CMD_DONE:
            break;


	case EVENT_NET_ERROR:
            if (mNetConnection)
                mNetConnection->Close();
            delete this;
            break;

	default:
            assert(!"Unknown event");
            return -1;
    }
    return 0;
}



///
/// We have a command in a buffer. So, parse out the command and
/// execute it if possible.
/// @param[in] iobuf: Buffer containing the command
/// @param[in] cmdLen: Length of the command in the buffer
///
bool
ClientSM::HandleClientCmd(IOBuffer *iobuf, int cmdLen)
{
    if (mClientIP.empty()) {
        mClientIP = mNetConnection->GetPeerName();
    }
    // we handle only GET and POST
    // Format: {GET/POST} <query string> HTTP/1.1\r\n
    // <the only stuff we care next is the Content-length> that is set for POST

    IOBuffer::IStream is(*iobuf, cmdLen);
    const char separator = ':';
    Properties prop;

    string verb;
    string action;
    string query;
    int contentLen;
    char *contentData = NULL;

    is >> verb;
    is >> action;
    prop.loadProperties(is, separator, false);
    prop.setValue("ClientIP", mClientIP);

    int nAvail = iobuf->BytesConsumable() - cmdLen;
    contentLen = prop.getValue("Content-Length", 0);
    if ((contentLen > 0) && (nAvail < contentLen))
        return false;

    iobuf->Consume(cmdLen);
    if (contentLen > 0) {
        contentData = new char[contentLen + 1];
        iobuf->CopyOut(contentData, contentLen);
        contentData[contentLen] = '\0';
    }

    WorkbuilderOp op;
    op.cseq = prop.getValue("Cseq", 1);
    // if the query has a ? mark in it, then stuff before is the workbuilder op
    action = removeLTSlashes(action);
    boost::algorithm::to_lower(action);
    string::size_type qMark = action.find('?');
    if (qMark != string::npos) {
        op.opName.assign(action, 0, qMark);
        op.opName = removeLTSlashes(op.opName);
        query.assign(action, qMark + 1, string::npos);
    }
    else {
        op.opName = action;
        if (contentData)
            query = contentData;
    }
    op.contentLen = contentLen;
    op.contentData = contentData;
    op.opType = getWorkbuilderOp(op.opName);
    loadParams(query, op.params);
    gWorkbuilder.handleOp(op);
    SendResponse(op);
    delete [] contentData;
    return true;
}
